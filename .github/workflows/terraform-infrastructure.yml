name: Terraform Infrastructure Deployment

on:
  push:
    branches:
      - main
    paths:
      - 'Terraform/**'
      - 'bootstrap/**'
      - '.github/workflows/terraform-infrastructure.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'Terraform/**'
      - 'bootstrap/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

jobs:
  terraform:
    name: Terraform Deployment
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-west-2' }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.3.5

      - name: Set environment
        run: |
          DEPLOY_ENV="${{ github.event.inputs.environment || 'dev' }}"
          echo "DEPLOY_ENV=$DEPLOY_ENV" >> $GITHUB_ENV
          echo "TF_VAR_environment=$DEPLOY_ENV" >> $GITHUB_ENV
          echo "PROJECT_NAME=neo4j-demos" >> $GITHUB_ENV

      # Bootstrap terraform state infrastructure with fixed output handling
      # Bootstrap terraform state infrastructure with proper multiline handling
      # Bootstrap terraform state infrastructure with clean output capturing
      - name: Bootstrap Terraform State
        working-directory: bootstrap
        run: |
          # Run bootstrap terraform
          terraform init
          terraform apply -auto-approve -var="environment=${{ env.DEPLOY_ENV }}" -var="project_name=${{ env.PROJECT_NAME }}" -var="aws_region=${{ secrets.AWS_REGION || 'us-west-2' }}"
          
          # Capture clean outputs by redirecting stderr and using grep to extract only the actual value
          BUCKET_NAME=$(terraform output -raw state_bucket_name 2>/dev/null | head -n1 | tr -d '\n\r')
          TABLE_NAME=$(terraform output -raw dynamodb_table_name 2>/dev/null | head -n1 | tr -d '\n\r')
          
          # Debug: Show extracted values
          echo "Captured bucket name: $BUCKET_NAME"
          echo "Captured table name: $TABLE_NAME"
          
          # Validate the outputs
          if [[ -z "$BUCKET_NAME" || "$BUCKET_NAME" == *"::debug::"* ]]; then
            echo "Error: Failed to capture clean bucket name" >&2
            exit 1
          fi
          
          if [[ -z "$TABLE_NAME" || "$TABLE_NAME" == *"::debug::"* ]]; then
            echo "Error: Failed to capture clean table name" >&2
            exit 1
          fi
          
          # Set environment variables
          echo "TF_STATE_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
          echo "TF_LOCK_TABLE=$TABLE_NAME" >> $GITHUB_ENV

      - name: Terraform Init
        working-directory: Terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" \
            -backend-config="key=${{ env.DEPLOY_ENV }}/terraform.tfstate" \
            -backend-config="region=${{ secrets.AWS_REGION || 'us-west-2' }}" \
            -backend-config="dynamodb_table=${{ env.TF_LOCK_TABLE }}"

      - name: Terraform Format
        working-directory: Terraform
        run: terraform fmt -check || true

      - name: Terraform Validate
        working-directory: Terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: Terraform
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
        working-directory: Terraform
        run: terraform apply -auto-approve tfplan

      - name: Save Terraform Outputs to SSM
        if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
        working-directory: Terraform
        run: |
          # Extract the cluster name from terraform output
          CLUSTER_NAME=$(terraform output -raw eks_cluster_name 2>/dev/null || echo "neo4j-demo-cluster")
          
          # Save cluster name to SSM Parameter Store
          aws ssm put-parameter \
            --name "/neo4j-demos/${{ env.DEPLOY_ENV }}/eks-cluster-name" \
            --value "$CLUSTER_NAME" \
            --type "String" \
            --overwrite
          
          echo "Saved EKS cluster name ($CLUSTER_NAME) to SSM parameter store"
          
          # Save other important outputs if available
          VPC_ID=$(terraform output -raw vpc_id 2>/dev/null || echo "")
          if [ ! -z "$VPC_ID" ]; then
            aws ssm put-parameter \
              --name "/neo4j-demos/${{ env.DEPLOY_ENV }}/vpc-id" \
              --value "$VPC_ID" \
              --type "String" \
              --overwrite
            echo "Saved VPC ID ($VPC_ID) to SSM parameter store"
          fi
          
          # Try to get domain name output
          DOMAIN_NAME=$(terraform output -raw domain_name 2>/dev/null || echo "neo4j-demos.example.com")
          aws ssm put-parameter \
            --name "/neo4j-demos/${{ env.DEPLOY_ENV }}/domain-name" \
            --value "$DOMAIN_NAME" \
            --type "String" \
            --overwrite
          echo "Saved domain name ($DOMAIN_NAME) to SSM parameter store"

#test8