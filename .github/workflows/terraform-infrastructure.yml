name: Terraform Infrastructure Deployment

on:
  push:
    branches:
      - main
    paths:
      - 'Terraform/**'
      - '.github/workflows/terraform-infrastructure.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'Terraform/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      terraform_action:
        description: 'Terraform action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply
          - destroy
      import_state:
        description: 'Import existing resources into state'
        required: false
        default: false
        type: boolean

jobs:
  terraform:
    name: Terraform Deployment
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: Terraform
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-west-2' }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.3.5

      - name: Set environment
        run: |
          DEPLOY_ENV="${{ github.event.inputs.environment || 'dev' }}"
          echo "DEPLOY_ENV=$DEPLOY_ENV" >> $GITHUB_ENV
          echo "TF_VAR_environment=$DEPLOY_ENV" >> $GITHUB_ENV

      - name: Terraform Init
        run: |
          # Initialize with remote backend if configured
          terraform init
          
          # Check if state file exists (non-zero exit code if missing)
          terraform state list &>/dev/null
          STATE_EXISTS=$?
          echo "STATE_EXISTS=$STATE_EXISTS" >> $GITHUB_ENV

      - name: Import Existing Resources
        if: ${{ github.event.inputs.import_state == 'true' || env.STATE_EXISTS != 0 }}
        run: |
          echo "Attempting to import existing resources into Terraform state..."
          
          # First attempt a refresh to see what might already exist
          terraform refresh || true
          
          # You may need to manually import resources that already exist
          # Example imports (modify as needed for your infrastructure):
          terraform import aws_iam_role.eks_node_role eks-node-role || true
          terraform import aws_iam_role.eks_admin eks-admin-role || true
          terraform import aws_iam_policy.eks_ecr_access arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/eks-ecr-access-policy || true
          terraform import aws_iam_policy.alb_controller_policy arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/ALBIngressControllerIAMPolicy || true
          terraform import aws_iam_policy.external_dns_policy arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/ExternalDNSIAMPolicy || true
          
          # Import ECR repositories
          terraform import 'aws_ecr_repository.demo_repos["neo4j-movie-recommendation"]' neo4j-movie-recommendation || true
          terraform import 'aws_ecr_repository.demo_repos["neo4j-basic-demo"]' neo4j-basic-demo || true
          terraform import 'aws_ecr_repository.demo_repos["neo4j-social-network"]' neo4j-social-network || true
          
          # Import S3 and DynamoDB resources
          terraform import aws_s3_bucket.demo_config neo4j-demo-config-${{ env.DEPLOY_ENV }} || true
          terraform import aws_dynamodb_table.demo_deployments neo4j-demo-deployments || true
          
          echo "Import operations completed. Some may have failed if the resources don't exist or aren't accessible."

      - name: Terraform Format
        run: terraform fmt -check || true

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        id: plan
        run: |
          # Create plan with detailed exit code
          terraform plan -detailed-exitcode -out=tfplan
          PLAN_EXIT_CODE=$?
          echo "PLAN_EXIT_CODE=$PLAN_EXIT_CODE" >> $GITHUB_ENV
          
          # 0 = No changes, 1 = Error, 2 = Changes present
          if [ $PLAN_EXIT_CODE -eq 1 ]; then
            echo "Terraform plan failed!"
            exit 1
          fi
          
          # Show the plan for visibility
          terraform show -no-color tfplan

      - name: Terraform Apply
        if: |
          (github.ref == 'refs/heads/main' && 
          github.event_name != 'pull_request' && 
          (github.event.inputs.terraform_action == 'apply' || github.event.inputs.terraform_action == '')) && 
          (env.PLAN_EXIT_CODE == '2' || env.PLAN_EXIT_CODE == '0')
        run: terraform apply -auto-approve tfplan

      - name: Terraform Destroy
        if: |
          github.ref == 'refs/heads/main' && 
          github.event_name != 'pull_request' && 
          github.event.inputs.terraform_action == 'destroy'
        run: terraform destroy -auto-approve

      - name: Save Terraform Outputs to SSM
        if: |
          github.ref == 'refs/heads/main' && 
          github.event_name != 'pull_request' && 
          github.event.inputs.terraform_action != 'destroy' &&
          (env.PLAN_EXIT_CODE == '2' || env.PLAN_EXIT_CODE == '0')
        run: |
          # Extract outputs from terraform
          
          # Try to get cluster name output, with fallback
          CLUSTER_NAME=$(terraform output -raw eks_cluster_name 2>/dev/null || echo "neo4j-demo-cluster")
          
          # Save cluster name to SSM Parameter Store
          aws ssm put-parameter \
            --name "/neo4j-demos/${{ env.DEPLOY_ENV }}/eks-cluster-name" \
            --value "$CLUSTER_NAME" \
            --type "String" \
            --overwrite
          
          echo "Saved EKS cluster name ($CLUSTER_NAME) to SSM parameter store"
          
          # Save other important outputs if available
          VPC_ID=$(terraform output -raw vpc_id 2>/dev/null || echo "")
          if [ -n "$VPC_ID" ]; then
            aws ssm put-parameter \
              --name "/neo4j-demos/${{ env.DEPLOY_ENV }}/vpc-id" \
              --value "$VPC_ID" \
              --type "String" \
              --overwrite
            echo "Saved VPC ID ($VPC_ID) to SSM parameter store"
          fi
          
          # Try to get domain name output
          DOMAIN_NAME=$(terraform output -raw domain_name 2>/dev/null || echo "neo4j-demos.example.com")
          aws ssm put-parameter \
            --name "/neo4j-demos/${{ env.DEPLOY_ENV }}/domain-name" \
            --value "$DOMAIN_NAME" \
            --type "String" \
            --overwrite
          echo "Saved domain name ($DOMAIN_NAME) to SSM parameter store"