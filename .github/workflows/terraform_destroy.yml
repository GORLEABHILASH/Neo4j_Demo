
name: Terraform Destroy
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to destroy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      confirmation:
        description: 'Type "DESTROY" to confirm destruction'
        required: true
        type: string

jobs:
  terraform-destroy:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.confirmation == 'DESTROY' }}
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-west-2' }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7
          
      - name: Fetch Terraform Backend Details
        id: backend_details
        run: |
          ENV="${{ github.event.inputs.environment }}"
          
          echo "Attempting to retrieve backend details from SSM..."
          
          # Try to get the bucket name from SSM, but use a default if not found
          if ! TF_STATE_BUCKET=$(aws ssm get-parameter --name "/terraform/$ENV/state_bucket" --query "Parameter.Value" --output text 2>/dev/null); then
            echo "SSM parameter for state bucket not found, using default naming convention"
            TF_STATE_BUCKET="neo4j-demos-terraform-state-$ENV"
          fi
          
          # Try to get the lock table name from SSM, but use a default if not found
          if ! TF_LOCK_TABLE=$(aws ssm get-parameter --name "/terraform/$ENV/lock_table" --query "Parameter.Value" --output text 2>/dev/null); then
            echo "SSM parameter for lock table not found, using default naming convention"
            TF_LOCK_TABLE="neo4j-demos-terraform-locks-$ENV"
          fi
          
          echo "Using backend details:"
          echo "  - Bucket: $TF_STATE_BUCKET"
          echo "  - Table: $TF_LOCK_TABLE"
          
          # Set output variables for use in other steps
          echo "bucket_name=$TF_STATE_BUCKET" >> $GITHUB_OUTPUT
          echo "table_name=$TF_LOCK_TABLE" >> $GITHUB_OUTPUT
          
          # Also set environment variables for this job
          echo "TF_STATE_BUCKET=$TF_STATE_BUCKET" >> $GITHUB_ENV
          echo "TF_LOCK_TABLE=$TF_LOCK_TABLE" >> $GITHUB_ENV
          
      # First destroy the main infrastructure
      - name: Terraform Init (Main Infrastructure)
        working-directory: Terraform
        continue-on-error: true
        id: terraform_init
        run: |
          terraform init \
            -backend-config="bucket=$TF_STATE_BUCKET" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="dynamodb_table=$TF_LOCK_TABLE" \
            -backend-config="region=${{ secrets.AWS_REGION || 'us-west-2' }}"
          
          # Store the exit code
          INIT_EXIT_CODE=$?
          echo "init_exit_code=$INIT_EXIT_CODE" >> $GITHUB_OUTPUT
          
          if [ $INIT_EXIT_CODE -ne 0 ]; then
            echo "Terraform init failed, attempting alternative approaches..."
          fi
      
      - name: Handle Terraform State Inconsistency
        if: steps.terraform_init.outputs.init_exit_code != '0'
        run: |
          echo "Handling Terraform state inconsistency..."
          
          # Get the current state from S3
          echo "Downloading current state file from S3..."
          aws s3 cp s3://$TF_STATE_BUCKET/terraform.tfstate ./current_state.json || true
          
          # If the state file exists locally, let's try to fix things
          if [ -f "./current_state.json" ]; then
            echo "Found state file, attempting to reset the DynamoDB lock..."
            
            # Calculate MD5 hash of the state file
            STATE_MD5=$(md5sum ./current_state.json | cut -d' ' -f1)
            echo "Calculated MD5: $STATE_MD5"
            
            # Update the DynamoDB table with the new digest
            aws dynamodb put-item \
              --table-name $TF_LOCK_TABLE \
              --item "{\"LockID\":{\"S\":\"terraform-state\"},\"Digest\":{\"S\":\"$STATE_MD5\"}}" || true
            
            echo "DynamoDB lock table has been updated with the new digest"
          else
            echo "Could not download state file, trying to bypass backend..."
          fi
          
          # Create empty terraform.tfstate file to start fresh
          echo "Creating empty local state file..."
          echo "{}" > ./terraform.tfstate
      
      - name: Terraform Init with Local Backend
        if: steps.terraform_init.outputs.init_exit_code != '0'
        working-directory: Terraform
        run: |
          echo "Attempting initialization with local backend..."
          
          # Create a temporary main.tf.new file with local backend
          grep -v "backend \"s3\"" main.tf > main.tf.new || true
          mv main.tf.new main.tf
          
          # Initialize with local backend
          terraform init
          
          echo "Local backend initialization complete"
      
      - name: Clean Up ECR Repositories
        run: |
          echo "Cleaning up ECR repositories before Terraform destroy..."
          
          # List of repositories to clean
          REPOS=("neo4j-basic-demo" "neo4j-social-network" "neo4j-movie-recommendation")
          
          for REPO in "${REPOS[@]}"; do
            echo "Checking repository: $REPO"
            
            # Check if repository exists
            if aws ecr describe-repositories --repository-names "$REPO" 2>/dev/null; then
              echo "Repository $REPO exists, deleting all images..."
              
              # Get image IDs and delete them
              IMAGE_IDS=$(aws ecr list-images --repository-name "$REPO" --query 'imageIds[*]' --output json)
              
              if [ "$IMAGE_IDS" != "[]" ] && [ -n "$IMAGE_IDS" ]; then
                echo "Deleting images from $REPO..."
                aws ecr batch-delete-image --repository-name "$REPO" --image-ids "$IMAGE_IDS" || true
                echo "Waiting for image deletion to complete..."
                sleep 10
              else
                echo "No images found in $REPO"
              fi
            else
              echo "Repository $REPO not found"
            fi
          done
      
      - name: Clean Up EKS Resources
        run: |
          echo "Cleaning up EKS resources before Terraform destroy..."
          
          # Check if EKS cluster exists
          if aws eks describe-cluster --name "neo4j-demo-cluster" 2>/dev/null; then
            echo "EKS cluster exists, cleaning up dependent resources..."
            
            # Get all node groups and delete them first
            NODE_GROUPS=$(aws eks list-nodegroups --cluster-name "neo4j-demo-cluster" --query "nodegroups[]" --output text)
            
            for NG in $NODE_GROUPS; do
              echo "Deleting node group: $NG"
              aws eks delete-nodegroup --cluster-name "neo4j-demo-cluster" --nodegroup-name "$NG"
              echo "Waiting for node group deletion..."
              aws eks wait nodegroup-deleted --cluster-name "neo4j-demo-cluster" --nodegroup-name "$NG"
            done
            
            # Check for any load balancers created by EKS service
            echo "Checking for EKS service load balancers..."
            SERVICES=$(aws eks list-services --cluster-name "neo4j-demo-cluster" --query "services[]" --output text 2>/dev/null || echo "")
            
            if [ -n "$SERVICES" ]; then
              for SVC in $SERVICES; do
                echo "Deleting service: $SVC"
                aws eks delete-service --cluster-name "neo4j-demo-cluster" --service-name "$SVC"
              done
            fi
          else
            echo "EKS cluster not found"
          fi
          
      - name: Clean Up Network Resources
        run: |
          echo "Cleaning up network resources before Terraform destroy..."
          
          # Get VPC ID
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=*neo4j-demos*" --query "Vpcs[0].VpcId" --output text)
          
          if [ "$VPC_ID" != "None" ] && [ -n "$VPC_ID" ]; then
            echo "Found VPC: $VPC_ID"
            
            # Release Elastic IPs
            echo "Checking for Elastic IPs..."
            EIP_ALLOCS=$(aws ec2 describe-addresses --filters "Name=domain,Values=vpc" --query "Addresses[?AssociationId].AllocationId" --output text)
            
            for EIP in $EIP_ALLOCS; do
              echo "Releasing Elastic IP: $EIP"
              aws ec2 release-address --allocation-id "$EIP"
            done
            
            # Find and delete NAT gateways
            echo "Checking for NAT Gateways..."
            NAT_GWS=$(aws ec2 describe-nat-gateways --filter "Name=vpc-id,Values=$VPC_ID" --query "NatGateways[?State!='deleted'].NatGatewayId" --output text)
            
            for NAT in $NAT_GWS; do
              echo "Deleting NAT Gateway: $NAT"
              aws ec2 delete-nat-gateway --nat-gateway-id "$NAT"
            done
            
            if [ -n "$NAT_GWS" ]; then
              echo "Waiting for NAT gateways to be deleted..."
              sleep 90
            fi
            
            # Find network interfaces
            echo "Checking for network interfaces..."
            ENIs=$(aws ec2 describe-network-interfaces --filters "Name=vpc-id,Values=$VPC_ID" --query "NetworkInterfaces[].NetworkInterfaceId" --output text)
            
            for ENI in $ENIs; do
              echo "Deleting network interface: $ENI"
              # First try to detach if attached
              ATTACHMENT=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI" --query "NetworkInterfaces[0].Attachment.AttachmentId" --output text)
              if [ "$ATTACHMENT" != "None" ] && [ -n "$ATTACHMENT" ]; then
                echo "Detaching $ENI first..."
                aws ec2 detach-network-interface --attachment-id "$ATTACHMENT" --force || true
                sleep 5
              fi
              aws ec2 delete-network-interface --network-interface-id "$ENI" || true
            done
          else
            echo "VPC not found"
          fi
          
      - name: Verify and Clean ALB Resources
        run: |
          echo "Checking for lingering ALB resources..."
          
          # List all load balancers and find ones that match your naming pattern
          LBS=$(aws elbv2 describe-load-balancers --query "LoadBalancers[?contains(LoadBalancerName, 'neo4j-demos') || contains(DNSName, 'neo4j-demos')].LoadBalancerArn" --output text)
          
          if [ -n "$LBS" ]; then
            echo "Found lingering load balancers, attempting cleanup..."
            
            for LB in $LBS; do
              echo "Deleting load balancer: $LB"
              # Delete listeners first to avoid dependency issues
              LISTENERS=$(aws elbv2 describe-listeners --load-balancer-arn $LB --query "Listeners[].ListenerArn" --output text)
              for LISTENER in $LISTENERS; do
                aws elbv2 delete-listener --listener-arn $LISTENER
              done
              
              # Delete the load balancer
              aws elbv2 delete-load-balancer --load-balancer-arn $LB
            done
            
            echo "Waiting for load balancers to be deleted..."
            sleep 60
          else
            echo "No lingering load balancers found."
          fi
          
          # Check for orphaned target groups
          TGS=$(aws elbv2 describe-target-groups --query "TargetGroups[?contains(TargetGroupName, 'neo4j-demos')].TargetGroupArn" --output text)
          
          if [ -n "$TGS" ]; then
            echo "Found lingering target groups, attempting cleanup..."
            
            for TG in $TGS; do
              echo "Deleting target group: $TG"
              aws elbv2 delete-target-group --target-group-arn $TG
            done
          else
            echo "No lingering target groups found."
          fi

      - name: Terraform Destroy (Main Infrastructure)
        working-directory: Terraform
        run: |
          # First try with -auto-approve
          terraform destroy -auto-approve || DESTROY_FAILED=true
          
          # If the destroy failed, try with force removal options
          if [ "${DESTROY_FAILED:-false}" = "true" ]; then
            echo "Standard destroy failed, attempting with additional force options..."
            
            # Trying with -refresh=false
            echo "Attempting destroy with refresh=false..."
            terraform destroy -auto-approve -refresh=false || true
          fi
        continue-on-error: true
        
      - name: Force Destroy Remaining Resources
        run: |
          echo "Checking for any remaining resources after Terraform destroy..."
          
          # Get VPC ID again
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=*neo4j-demos*" --query "Vpcs[0].VpcId" --output text)
          
          if [ "$VPC_ID" != "None" ] && [ -n "$VPC_ID" ]; then
            echo "VPC still exists: $VPC_ID. Performing manual cleanup..."
            
            # List all VPC Endpoints and delete them
            echo "Removing VPC Endpoints..."
            ENDPOINTS=$(aws ec2 describe-vpc-endpoints --filters "Name=vpc-id,Values=$VPC_ID" --query "VpcEndpoints[].VpcEndpointId" --output text)
            for ENDPOINT in $ENDPOINTS; do
              echo "Deleting VPC Endpoint: $ENDPOINT"
              aws ec2 delete-vpc-endpoints --vpc-endpoint-ids $ENDPOINT || true
            done
            
            # Delete all network ACLs except default
            echo "Removing network ACLs..."
            NACLS=$(aws ec2 describe-network-acls --filters "Name=vpc-id,Values=$VPC_ID" --query "NetworkAcls[?!IsDefault].NetworkAclId" --output text)
            for NACL in $NACLS; do
              aws ec2 delete-network-acl --network-acl-id $NACL || true
            done
            
            # Delete all security groups except default
            echo "Removing security groups..."
            SGs=$(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=$VPC_ID" --query "SecurityGroups[?GroupName!='default'].GroupId" --output text)
            for SG in $SGs; do
              # First remove any security group rules that reference other security groups
              echo "Removing rules from security group: $SG"
              
              # Remove ingress rules
              INGRESS_RULES=$(aws ec2 describe-security-group-rules --filters "Name=group-id,Values=$SG" "Name=is-egress,Values=false" --query "SecurityGroupRules[].SecurityGroupRuleId" --output text)
              if [ -n "$INGRESS_RULES" ]; then
                aws ec2 revoke-security-group-ingress --group-id $SG --security-group-rule-ids $INGRESS_RULES || true
              fi
              
              # Remove egress rules
              EGRESS_RULES=$(aws ec2 describe-security-group-rules --filters "Name=group-id,Values=$SG" "Name=is-egress,Values=true" --query "SecurityGroupRules[].SecurityGroupRuleId" --output text)
              if [ -n "$EGRESS_RULES" ]; then
                aws ec2 revoke-security-group-egress --group-id $SG --security-group-rule-ids $EGRESS_RULES || true
              fi
              
              sleep 5
              aws ec2 delete-security-group --group-id $SG || true
            done
            
            # Delete all subnets
            echo "Removing subnets..."
            SUBNETS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query "Subnets[].SubnetId" --output text)
            for SUBNET in $SUBNETS; do
              aws ec2 delete-subnet --subnet-id $SUBNET || true
            done
            
            # Delete all route tables except the main one
            echo "Removing route tables..."
            RTs=$(aws ec2 describe-route-tables --filters "Name=vpc-id,Values=$VPC_ID" --query "RouteTables[?Associations[0].Main!=\`true\`].RouteTableId" --output text)
            for RT in $RTs; do
              # First remove associations
              ASSOCS=$(aws ec2 describe-route-tables --route-table-id $RT --query "RouteTables[0].Associations[?Main!=\`true\`].RouteTableAssociationId" --output text)
              for ASSOC in $ASSOCS; do
                aws ec2 disassociate-route-table --association-id $ASSOC || true
              done
              # Delete non-default routes from main route table
              ROUTES=$(aws ec2 describe-route-tables --route-table-id $RT --query "RouteTables[0].Routes[?GatewayId != 'local'].DestinationCidrBlock" --output text)
              for ROUTE in $ROUTES; do
                aws ec2 delete-route --route-table-id $RT --destination-cidr-block $ROUTE || true
              done
              aws ec2 delete-route-table --route-table-id $RT || true
            done
            
            # Detach and delete internet gateway
            echo "Removing internet gateway..."
            IGW=$(aws ec2 describe-internet-gateways --filters "Name=attachment.vpc-id,Values=$VPC_ID" --query "InternetGateways[0].InternetGatewayId" --output text)
            if [ -n "$IGW" ]; then
              aws ec2 detach-internet-gateway --internet-gateway-id $IGW --vpc-id $VPC_ID || true
              sleep 5
              aws ec2 delete-internet-gateway --internet-gateway-id $IGW || true
            fi
            
            # Try to delete remaining network interfaces
            echo "Final check for network interfaces..."
            ENIs=$(aws ec2 describe-network-interfaces --filters "Name=vpc-id,Values=$VPC_ID" --query "NetworkInterfaces[].NetworkInterfaceId" --output text)
            for ENI in $ENIs; do
              echo "Trying to delete network interface: $ENI"
              ATTACHMENT=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI" --query "NetworkInterfaces[0].Attachment.AttachmentId" --output text)
              if [ "$ATTACHMENT" != "None" ] && [ -n "$ATTACHMENT" ]; then
                aws ec2 detach-network-interface --attachment-id "$ATTACHMENT" --force || true
                sleep 10
              fi
              aws ec2 delete-network-interface --network-interface-id "$ENI" || true
            done
            
            # Finally delete the VPC
            echo "Deleting VPC..."
            sleep 10  # Give AWS time to recognize all resources are deleted
            aws ec2 delete-vpc --vpc-id $VPC_ID || true
          else
            echo "VPC successfully deleted"
          fi
          
          # Clean up ECR repositories if they still exist
          echo "Final check for ECR repositories..."
          for REPO in "neo4j-basic-demo" "neo4j-social-network" "neo4j-movie-recommendation"; do
            if aws ecr describe-repositories --repository-names "$REPO" 2>/dev/null; then
              echo "Forcing deletion of repository: $REPO"
              aws ecr delete-repository --repository-name "$REPO" --force || true
            fi
          done
        
      # Then destroy the bootstrap resources
      - name: Terraform Init (Bootstrap)
        working-directory: bootstrap
        run: terraform init
        
      - name: Terraform Destroy (Bootstrap)
        working-directory: bootstrap
        run: terraform destroy -auto-approve
        
      # Clean up remaining resources
      - name: Clean Up Resources
        run: |
          ENV="${{ github.event.inputs.environment }}"
          BUCKET_NAME="${TF_STATE_BUCKET}"
          TABLE_NAME="${TF_LOCK_TABLE}"
          
          echo "Removing SSM Parameters..."
          aws ssm delete-parameter --name "/terraform/$ENV/state_bucket" || true
          aws ssm delete-parameter --name "/terraform/$ENV/lock_table" || true
          
          echo "Checking for bucket and table cleanup..."
          
          # Final check for S3 bucket - handle versioned objects
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Cleaning up S3 bucket $BUCKET_NAME..."
            
            # Delete all versions and delete markers
            echo "Removing all versions from bucket..."
            aws s3api list-object-versions --bucket "$BUCKET_NAME" --output json | \
            jq -r '.Versions[] | .Key + " " + .VersionId' | \
            while read KEY VERSIONID; do
              echo "Deleting object: $KEY ($VERSIONID)"
              aws s3api delete-object --bucket "$BUCKET_NAME" --key "$KEY" --version-id "$VERSIONID"
            done
            
            # Delete all delete markers
            echo "Removing all delete markers from bucket..."
            aws s3api list-object-versions --bucket "$BUCKET_NAME" --output json | \
            jq -r '.DeleteMarkers[] | .Key + " " + .VersionId' | \
            while read KEY VERSIONID; do
              echo "Deleting delete marker: $KEY ($VERSIONID)"
              aws s3api delete-object --bucket "$BUCKET_NAME" --key "$KEY" --version-id "$VERSIONID"
            done
            
            # Now try to delete the bucket
            echo "Deleting bucket..."
            aws s3api delete-bucket --bucket "$BUCKET_NAME"
            echo "Bucket deletion attempted"
          fi
          
          # Final check for DynamoDB table
          if aws dynamodb describe-table --table-name "$TABLE_NAME" 2>/dev/null; then
            echo "Cleaning up DynamoDB table $TABLE_NAME..."
            aws dynamodb delete-table --table-name "$TABLE_NAME"
            echo "Table deletion initiated"
          fi
          
          echo "Destruction process completed."